## 内联（in-line）

所谓内联看如下代码

```typescript
describe("内联", () => {
  it("normal addTodo", () => {
    // given
    // 低层次的代码
    const todo = {
      title: "吃饭",
      content: "今天要和小明去吃饭",
    };

    // when
    addTodo(todo);

    // then
    expect(todos[0]).toEqual(todo);
  });
});
```

像这种把 `todo` 变量直接定义在一个 case 内部的方式就叫做内联。这种内联的方式主要优点就是方便，测试用例想要啥数据我们就直接就近产生，但是这也带来了很多问题，比如他会造成很多重复的代码，看如下代码

```typescript
describe("内联", () => {
  it("normal addTodo", () => {
    // given
    // 低层次的代码
    const todo = {
      title: "吃饭",
      content: "今天要和小明去吃饭",
    };

    // when
    addTodo(todo);

    // then
    expect(todos[0]).toEqual(todo);
  });
  it(" addTodo with top command", () => {
    // given
    const todo = {
      title: "top: 吃饭",
      content: "今天要和小明去吃饭",
    };

    // when
    addTodo(todo);

    // then
    expect(todos[0].title).toEqual("吃饭");
  });
  it(" addTodo with reverse command", () => {
    // given
    const todo = {
      title: "reverse: 吃饭",
      content: "今天要和小明去吃饭",
    };

    // when
    addTodo(todo);

    // then
    expect(todos[0].title).toEqual("饭吃");
  });
});
```

可以看到几个测试用例中各自定义了 todo 变量，这不仅带来了重复而且还增加了维护的难度，如果 `todo` 对象需要增加属性的话，那就得找到所有的 `todo` 都加一遍。

其次，如果某个测试需要的数据比较复杂的话，如果写到内联的话，可读性可以想象会比较的差

```typescript
describe("内联", () => {
  it("难理解的 given ", () => {
    // 简单容易理解 可读性要高
    // todo 需要一个更贴切的 case
    // given
    const userA = {
      name: "cxr",
      age: 18,
    };

    const userB = {
      name: "cxr",
      age: 18,
    };

    const userC = {
      name: "cxr",
      age: 18,
    };

    const playerA = new Player(new Weapons("冲锋枪"));
    playerA.life = 3;
    playerA.attack = () => {
      return 3;
    };
    const playerB = new Player(new Weapons("手枪"));
    playerA.life = 2;
    playerA.attack = () => {
      return 3;
    };

    // when
    fighting(playerA, playerB, [userA, userB, userC]);

    // then
    // expect()
  });
});
```

所以什么时候使用内联的方式呢？

1. 比较简单切独立的数据可以写到内联
2. 刚开始写测试的时候为了方便和快速（这种情况会等着后面一步一步的重构的）

## 委托（Delegate）

## 内联（Implicit）
